:title: Some1 Like You
:data-transition-duration: 150

:css: fonts.css
:css: presentation.css


\newenvironment{hs}[1]{.. code:: haskell
}{}
\newenvironment{raw}[1]{.. raw:: html

  <pre>}{
  </pre>
}
\newcommand{\$}{\begin{verbatim}$\end{verbatim}}
\newcommand{\todo}[2]{#2}
\newcommand{\note}[1]{<span class="new">#1</span>}
\newcommand{\wat}[1]{<span class="wat">#1</span>}

----

:id: title

.. raw:: html

  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>

  <h1>Some1 Like You</h1>
  <h2>Dependent Pairs in Haskell</h2>
  <h3>A talk by <span>Sandy Maguire</span></h3>
  <h4>reasonablypolymorphic.com</h4>

----

\begin{hs}
  data Event = WakeUp
             | Eat Meal
             | RockOut Song Duration

  instance FromJSON Event
\end{hs}

----

\begin{hs}
  type Req  = ReqBody '[JSON] Value
  type Resp = Post    '[JSON] Response

  type EventAPI = "api" :> "event" :>
         ( "wake-up"  :> Req :> Resp
      :<|> "eat"      :> Req :> Resp
      :<|> "rock-out" :> Req :> Resp
         )
\end{hs}

----

\begin{hs}
  importEvent :: Value -> ExceptT ServantErr IO Response
  importEvent blob =
    case fromJSON blob of
      Error   err -> throwError err
      Success ev  -> pure \$ Response ev
\end{hs}

----

\begin{hs}
  wakeUp  = importEvent
  eat     = importEvent
  rockOut = importEvent

  eventServer :: Server EventAPI
  eventServer = serve \$
    wakeUp :<|> eat :<|> rockOut
\end{hs}

----

\begin{hs}
  data PayloadWakeUp  = \todo{rename these so they dont clash with datakinds later}{WakeUp}
  data PayloadEat     = Eat Meal
  data PayloadRockOut = RockOut Song Duration

  instance FromJSON PayloadWakeUp
  instance FromJSON PayloadEat
  instance FromJSON PayloadRockOut
\end{hs}

----

\begin{raw}
  data Event = PayloadWakeUp  \note{PayloadWakeUp}
             | PayloadEat     \note{PayloadEat}
             | PayloadRockOut \note{PayloadRockOut}

  \note{makePrisms ''Event}
\end{raw}

----

\begin{raw}
  importEvent :: \note{FromJSON e}
              \note{=> Prism' Event e}
              -> Value
              -> ExceptT ServantErr IO Response
  importEvent \note{prism} blob =
    case fromJSON blob of
      Error   err -> throwError err
      Success e   -> pure . Response \$ \note{review prism} e
\end{raw}

----

\begin{raw}
  {-# LANGUAGE RankNTypes #-}
\end{raw}

----

\begin{raw}
  wakeUp  = importEvent \note{_PayloadWakeUp}
  eat     = importEvent \note{_PayloadEat}
  rockOut = importEvent \note{_PayloadRockOut}

  eventServer :: Server EventAPI
  eventServer = \todo{notice there is no way to prove we have the right types here}{serve} \$
    wakeUp :<|> eat :<|> rockOut
\end{raw}

----

\begin{hs}
  data EventType = WakeUp | Eat | RockOut
\end{hs}

----

\begin{hs}
  data family Payload (e :: EventType)
\end{hs}

----

\begin{raw}
  \note{{-# LANGUAGE DataKinds    #-}}
  {-# LANGUAGE RankNTypes   #-}
  \note{{-# LANGUAGE TypeFamilies #-}}
\end{raw}

----

\begin{raw}
  data \note{instance Payload 'WakeUp}  = WakeUp
  data \note{instance Payload 'Eat}     = Eat Meal
  data \note{instance Payload 'RockOut} = RockOut Song Duration

  instance FromJSON (Payload 'WakeUp)
  instance FromJSON (Payload 'Eat)
  instance FromJSON (Payload 'RockOut)
\end{raw}

----

\begin{hs}
  data Event where
    MkEvent :: Payload (et :: EventType) -> Event
\end{hs}

----

\begin{raw}
  importEvent :: \note{forall (et :: EventType)}
               . FromJSON (\note{Payload} et)
              -> \note{Proxy et}
              -> Value
              -> ExceptT ServantErr IO Response

  importEvent \note{_} blob =
    case fromJSON blob of
      Error err ->
        throwError err

      Success (e \note{:: Payload et}) ->
        pure . Response \$ \note{MkEvent} e
\end{raw}

----

\begin{raw}
  {-# LANGUAGE DataKinds           #-}
  \note{{-# LANGUAGE KindSigs            #-}}
  {-# LANGUAGE RankNTypes          #-}
  \note{{-# LANGUAGE ScopedTypeVariables #-}}
  {-# LANGUAGE TypeFamilies        #-}
\end{raw}


----

\begin{raw}
  wakeUp  = importEvent \note{(Proxy @'WakeUp)}
  eat     = importEvent \note{(Proxy @'Eat)}
  rockOut = importEvent \note{(Proxy @'RockOut)}

  eventServer :: Server EventAPI
  eventServer = \todo{notice there is no way to prove we have the right types here}{serve} \$
    wakeUp :<|> eat :<|> rockOut
\end{raw}

----

\begin{raw}
  {-# LANGUAGE DataKinds           #-}
  {-# LANGUAGE KindSigs            #-}
  {-# LANGUAGE RankNTypes          #-}
  {-# LANGUAGE ScopedTypeVariables #-}
  \note{{-# LANGUAGE TypeApplications    #-}}
  {-# LANGUAGE TypeFamilies        #-}
\end{raw}

----

\begin{raw}
  type Req  = ReqBody '[JSON] Value
  type Resp = Post    '[JSON] Response

  type EventAPI = "api" :> "event" :>
         \note{Capture "event-type" EventType :> Req :> Resp}
\end{raw}

----

\begin{raw}
  importEvent :: \note{EventType}
              -> Value
              -> ExceptT ServantErr IO Response

  importEvent \wat{et} blob =
    case fromJSON blob of
      Error err ->
        throwError err

      Success (e :: Payload \wat{et}) ->
        pure . Response \$ MkEvent e
\end{raw}

----

- OR CAN IT
  - introducing singletons
  - singletons allow us to bridge the gap between types and terms
  - think about the type ()
    - if you know what type it is, you know the value of it
    - if you have a value of (), you know what type it is
    - we have an injective function from these terms to types
      - because it's injective we can go both directions
  - the problem is that dealing with these things at the term level is hard -- since they all have different types
    - we can existentalize over them to let us fit them into something at the term level
    - data SomeSing k where SomeSing :: (Sing a :: k) -> SomeSing k
  - singletons also give us the ability to lift in and out of singletons
    - toSing :: SingKind k => k -> SomeSing k
    - fromSing :: Sing (a :: k) -> k

----

\begin{raw}
  importEvent :: EventType
              -> Value
              -> ExceptT ServantErr IO Response

  importEvent etype blob =
    \note{withSomeSing etype \$ \ (_ :: Sing et) ->}
      case fromJSON blob of
        Error err ->
          throwError err

        Success (e :: Payload et) ->
          pure . Response \$ MkEvent e
\end{raw}

----

No instance `FromJSON` for type `et`.

----

\begin{hs}
  dictFromJSON :: ( FromJSON (Payload 'WakeUp)
                  , FromJSON (Payload 'Eat)
                  , FromJSON (Payload 'RockOut)
                  )
               => Sing (a :: EventType)
               -> Dict (FromJSON (Payload a))
\end{hs}

----

add constraint kind

----

\begin{hs}
  dictFromJSON :: ( FromJSON (Payload 'WakeUp)
                  , FromJSON (Payload 'Eat)
                  , FromJSON (Payload 'RockOut)
                  )
               => Sing (a :: EventType)
               -> Dict (FromJSON (Payload a))

  dictFromJSON = \case
    SWakeUp  -> Dict
    SEat     -> Dict
    SRockOut -> Dict
\end{hs}

----

add lambda case

----

\begin{raw}
  importEvent :: EventType
              -> Value
              -> ExceptT ServantErr IO Response

  importEvent etype blob =
    withSomeSing etype \$ \ (\note{setype} :: Sing et) ->
      \note{case dictFromJSON setype of}
        \note{Dict ->}
          case fromJSON blob of
            Error err ->
              throwError err

            Success (e :: Payload et) ->
              pure . Response \$ MkEvent e
\end{raw}

----

\begin{raw}
  eventServer :: Server EventAPI
  eventServer = serve \note{importEvent}
\end{raw}

----

- sweet! our API implementation is done! we now get all of this for free!
  - we can add new event types to our enum
  - but we'll get a exhaustiveness error on dictFromJSON
  - which it can only be fixed if we add a data instance for the new type
  - and then everything works.
  - COMPILER DRIVEN CODING!

----

- but what about the other part of the problem?
  - we also want to serialize these things and stick them into a pipe for downstream consumers
  - for simplicity we'll encode them as json
  - assume we have some `Value -> IO ()` pipe function that sends things downstream. how can we call this function?
    - we need a ToJSON Event, duh
    - well if we want any chance of encoding it, we're going to need to know that ToJSON is total over the sum space
    - also need dictToJSON

----

\begin{hs}
  dictToJSON :: ( ToJSON (Payload 'WakeUp)
                , ToJSON (Payload 'Eat)
                , ToJSON (Payload 'RockOut)
                )
             => Sing (a :: EventType)
             -> Dict (FromJSON (Payload a))

  dictFromJSON = \case
    SWakeUp  -> Dict
    SEat     -> Dict
    SRockOut -> Dict
\end{hs}

----

- but you'll notice that besides the constraints, this function is exactly the same implementation as dictFromJSON
  - maybe we can lift this!
    - dictEvent :: (c ...) => Sing (a :: EventType) -> Dict (c (Payload a))
  - this means that we can get a dictionary for any c (Payload a) so long as c is total over Payload a!
    - fucking sweet!

----

\begin{raw}
  dictPayload :: ( \note{c} (Payload 'WakeUp)
                 , \note{c} (Payload 'Eat)
                 , \note{c} (Payload 'RockOut)
                 )
              => Sing (a :: EventType)
              -> Dict (\note{c} (Payload a))

  dictPayload = \case
    SWakeUp  -> Dict
    SEat     -> Dict
    SRockOut -> Dict
\end{raw}

----

\begin{hs}
  instance ToJSON Event where
    toJSON (MkEvent payload) = toJSON payload
\end{hs}

----

No instance `toJSON` for `Payload a`

Uh oh, we don't have a singleton to actually use to get our `dictPayload`!

Scrub lords!

----

\begin{raw}
  data Event where
    MkEvent :: \note{Sing (et :: EventType)}
            -> Payload et
            -> Event
\end{raw}

----

\begin{hs}
  instance ToJSON Event where

    toJSON (MkEvent (setype :: Sing etype) payload) =
      case dictPayload @ToJSON setype of
        Dict ->
          object [ "type"    .= fromSing setype
                 , "payload" .= payload
                 ]
\end{hs}

----

- this is known as a Sigma type AKA a dependent pair
  - in the literature it is
  - Sigma_{a :: EventType} Payload(a)
    - with values
    - (a :: EventType, payload :: Payload a) :: Sigma_{a :: EventType} Payload(a)
  - if you remember your highschool algebra, expanding this out algebraically is
  - Payload(a1) + Payload(a2) + Payload(a3) etc
  - aka THIS IS ACTUALLY THE EXACT SUM TYPE WE WERE BUILDING BY HAND BEFORE

----

$$\\sum_\\text{a :: EventType} \\text{Payload}(a)$$

----

\begin{hs}
  data Some1 (f :: k -> *) where
    Some1 :: Sing (a :: k) -> f a -> Some1 f
\end{hs}

----

Add polykinds.

----

\begin{raw}
  type Event = \note{Some1 Payload}
\end{raw}

----

\begin{hs}
  class Dict1 (c :: ok -> Constraint)
              (f :: ik -> ok) where
    dict1 :: Sing (a :: ik) -> Dict (c (f a))
\end{hs}

