:title: Some1 Like You
:data-transition-duration: 150

:css: fonts.css
:css: presentation.css


\newenvironment{table}{.. raw:: html

  <table>}{
  </table>
}

\newenvironment{hs}{.. code:: haskell
}{}
\newenvironment{raw}{.. raw:: html

  <pre>}{
  </pre>
}
\newenvironment{custom}{.. raw:: html

  <pre class="highlight code haskell">}{
  </pre>
}
\newcommand{\$}{\begin{verbatim}$\end{verbatim}}
\newcommand{\todo}[2]{#2}
\newcommand{\note}[1]{<span class="new">#1</span>}
\newcommand{\wat}[1]{<span class="wat">#1</span>}
\newcommand{\type}[1]{<span class="type">#1</span>}
\newcommand{\kind}[1]{<span class="kind">#1</span>}
\newcommand{\syn}[2]{<span class="#1">#2</span>}
\newcommand{\pragma}[1]{\{-# LANGUAGE #1 #-\}}
\newcommand{\pragmasyn}[1]{\syn{cm}{\{-# LANGUAGE #1 #-\}}}
\newcommand{\b}[1]{<pre class="highlight haskell code">#1</pre>}

----

:id: title

.. raw:: html

  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>

  <h1>Some1 Like You</h1>
  <h2>Dependent Pairs in Haskell</h2>
  <h3>A talk by <span>Sandy Maguire</span></h3>
  <h4>reasonablypolymorphic.com</h4>

----

An (almost) real life example.
==============================

We will make a simple data-ingestion platform for our life-tracking app.

The program will provide an API with a unique endpoint for each distinct type of data we can ingest.

----

Survey says: big growth!
========================

The marketing team says that by the end of the year, we'll have over 500 different "events" we'll want to be able to
ingest.

----

At this scale, *any* boilerplate is bad news.
=============================================

Boilerplate is boring to write and easy to get wrong.

----

A first attempt.
================

\begin{hs}
  data Event = WakeUp
             | Eat     Meal
             | RockOut Song Duration
\end{hs}

----

\begin{hs}
  instance FromJSON Event where
    parseJSON = parseWakeUp
            <|> parseEat
            <|> parseRockOut
\end{hs}

----

The API.
========

\begin{hs}
  type Req  = ReqBody '[JSON] Value
  type Resp = Post    '[JSON] Response

  type EventAPI =
    "api" :> "event" :>
               ( "wake-up"  :> Req :> Resp
            :<|> "eat"      :> Req :> Resp
            :<|> "rock-out" :> Req :> Resp
               )
\end{hs}

----

\begin{hs}
  importEvent :: Value -> ExceptT ServantErr IO Response
  importEvent blob =
    case fromJSON blob of
      Error   err -> throwM err
      Success ev  -> pure \$ Response ev
\end{hs}

----

\begin{hs}
  wakeUp  = importEvent
  eat     = importEvent
  rockOut = importEvent

  eventServer :: Server EventAPI
  eventServer = serve \$
    wakeUp :<|> eat :<|> rockOut
\end{hs}

----

Notice how there is no type safety here.

Our *wake-up* endpoint will happily accept a *eat* payload.

----

We can do better!
=================

Separate the constructors of our sum type into their own types.

----

\begin{hs}
  data PayloadWakeUp  = PayloadWakeUp
  data PayloadEat     = PayloadEat     Meal
  data PayloadRockOut = PayloadRockOut Song Duration

  instance FromJSON PayloadWakeUp
  instance FromJSON PayloadEat
  instance FromJSON PayloadRockOut
\end{hs}

----

\begin{raw}
  \pragma{TemplateHaskell}

  data Event = EventWakeUp  \note{PayloadWakeUp}
             | EventEat     \note{PayloadEat}
             | EventRockOut \note{PayloadRockOut}

  \note{makePrisms ''Event}
\end{raw}

----

Optics provide type safety!
===========================

We can use these prisms to lift our payload types into our `Event` type.

----

\begin{raw}
  \pragma{RankNTypes}

  importEvent :: \note{FromJSON e}
              \note{=> Prism' Event e}
              -> Value
              -> ExceptT ServantErr IO Response
  importEvent \note{prism} blob =
    case fromJSON blob of
      Error   err -> throwM err
      Success e   -> pure . Response \$ \note{review prism} e
\end{raw}

----

Server upgrades.
================

\begin{raw}
  wakeUp  = importEvent \note{_PayloadWakeUp}
  eat     = importEvent \note{_PayloadEat}
  rockOut = importEvent \note{_PayloadRockOut}

  eventServer :: Server EventAPI
  eventServer = \todo{notice there is no way to prove we have the right types here}{serve} \$
    wakeUp :<|> eat :<|> rockOut
\end{raw}

----

We've gained type safety!
=========================

The endpoints will no longer accept payloads of the wrong type.

----

The compiler doesn't know that our new payload types are related.

----

We can do better!
=================

Grouping our payload types together might provide opportunities for more clever tricks.

----

A brief interlude.
==================

On data kinds and type families.

----

Data kinds lifts *values* to **types**, and *types* to **kinds**.

Wat?

----

\begin{hs}
  data Bool = True
            | False
\end{hs}

\begin{raw}
\end{raw}


begets, via DataKinds:

\begin{custom}

  \syn{kc}{kind} \kind{Bool} where
    \syn{kc}{type} '\type{True}
    \syn{kc}{type} '\type{False}
\end{custom}

----

Type families.
==============

A **type family** is a function that returns a type.

Type families only exist at the type level.

----

We can write type families over DataKinds.

----

Back to our regularly scheduled talk.
=====================================

----

\begin{hs}
  \pragma{DataKinds   }
  \pragma{TypeFamilies}

  data EventType = WakeUp | Eat | RockOut
\end{hs}

\begin{custom}
  \syn{kc}{data family} \syn{kt}{Payload} (\type{e} :: \kind{EventType})
\end{custom}

----

\begin{raw}
  data \note{instance Payload '\type{WakeUp}}  = WakeUp
  data \note{instance Payload '\type{Eat}}     = Eat Meal
  data \note{instance Payload '\type{RockOut}} = RockOut Song Duration

  instance FromJSON (Payload 'WakeUp)
  instance FromJSON (Payload 'Eat)
  instance FromJSON (Payload 'RockOut)
\end{raw}

----

Data types for free.
====================

Armed with this type family, we can get our old sum type for free.

----

\begin{hs}
  \pragma{GADTs}

  data Event where
    MkEvent :: Payload (et :: EventType) -> Event
\end{hs}

----

\begin{raw}
  \note{\pragma{AllowAmbiguousTypes}}
  \note{\pragma{KindSignatures     }}
  \note{\pragma{ScopedTypeVariables}}

  importEvent :: \note{forall (\type{et} :: \kind{EventType})}
               . FromJSON (Payload \type{et})
              -> Value
              -> ExceptT ServantErr IO Response

  importEvent blob =
    case fromJSON blob of
      Error err ->
        throwM err

      Success (e \note{:: Payload \type{et}}) ->
        pure . Response \$ \note{MkEvent} e
\end{raw}

----

Make it compile again.
======================

\begin{raw}
  \note{\pragma{TypeApplications}}

  wakeUp  = importEvent \note{@'\type{WakeUp}}
  eat     = importEvent \note{@'\type{Eat}}
  rockOut = importEvent \note{@'\type{RockOut}}

  eventServer :: Server EventAPI
  eventServer = serve \$
    wakeUp :<|> eat :<|> rockOut
\end{raw}

----

Notice that we've eliminated some boilerplate.

We no longer need to keep our Event type in sync with the payload types.

----

We can do better!
=================

Generating the API definition automatically would remove a lot more boilerplate.

----

\begin{raw}
  type Req  = ReqBody '[JSON] Value
  type Resp = Post    '[JSON] Response

  type EventAPI = "api" :> "event" :>
         \note{Capture "event-type" EventType :> Req :> Resp}
\end{raw}

----

\begin{raw}
  importEvent :: \note{EventType}
              -> Value
              -> ExceptT ServantErr IO Response

  importEvent et blob =
    case fromJSON blob of
      Error err ->
        throwM err

      Success (e :: Payload \type{et}) ->
        pure . Response \$ MkEvent e
\end{raw}

----

A brief interlude.
==================

This turns out to be a problem with a solution.

----

Consider Unit.
==============

\begin{hs}
  () :: ()
\end{hs}

If you know what value you have, you know its type, and vice-versa.

----

Singletons generalize this.
===========================

We'll introduce a new type for each value we'd like to move to the type level.

Unfortunately, not the same types as provided by DataKinds.

----

\begin{custom}
  \pragma{PolyKinds }
  \pragma{TypeInType}

  \syn{kr}{data family} \syn{kt}{Sing} (\type{a} :: \kind{k})

  \syn{kr}{class} \syn{kt}{SingKind} \kind{k} where
    toSing   :: k -> \syn{kt}{SomeSing} \kind{k}
    fromSing :: \syn{kt}{Sing} (\type{a} :: \kind{k}) -> k
\end{custom}

----

\begin{custom}
  \syn{kr}{data instance} (\syn{kt}{Sing} '\type{True})  = \syn{kt}{STrue}
  \syn{kr}{data instance} (\syn{kt}{Sing} '\type{False}) = \syn{kt}{SFalse}


  \syn{kr}{instance} \syn{kt}{SingKind} \kind{Bool} where
    toSing b = \syn{kr}{case} b \syn{kr}{of}
      \syn{kt}{True}  -> \syn{kt}{SomeSing STrue}
      \syn{kt}{False} -> \syn{kt}{SomeSing SFalse}

    fromSing s = \syn{kr}{case} s \syn{kr}{of}
      \syn{kt}{STrue} -> \syn{kt}{True}
      \syn{kt}{False} -> \syn{kt}{False}
\end{custom}

----

\begin{hs}
  {-# LANGUAGE TemplateHaskell #-}

  \$(singletons [d|
      data Bool = True
                | False
      |])
\end{hs}

----

\newcommand{\singhead}{<thead>\sing{Value}{Type}{Singleton}{Singleton Type}{Existential Type}</thead>}
\newcommand{\sing}[5]{<tr><td>#1</td><td>#2</td><td>#3</td><td>#4</td><td>#5</td></tr>}
\newcommand{\singb}[2]{\sing{\b{\syn{kt}{#1}}}{\b{\syn{kt}{#2}}}{\b{\syn{kt}{S#1}}}{\b{Sing '\type{#1}}}{\b{SomeSing \kind{#2}}}}

\begin{table}
  \singhead
  \singb{True}{Bool}
  \singb{False}{Bool}
\end{table}

----

Not just for Bools!
===================

\begin{hs}
  \$(singletons [d|
      data EventType = WakeUp
                     | Eat
                     | RockOut
      |])
\end{hs}

----

\begin{table}
  \singhead
  \singb{WakeUp}{EventType}
  \singb{Eat}{EventType}
  \singb{RockOut}{EventType}
\end{table}

----

\begin{custom}
  withSomeSing :: \syn{kt}{SingKind} \kind{k}
               => k
               -> (\syn{kc}{forall} (\type{a} :: \kind{k}). \syn{kt}{Sing} \type{a} -> r)
               -> r
\end{custom}

----

Back to our regularly scheduled talk.
=====================================

----

\begin{raw}
  importEvent :: EventType
              -> Value
              -> ExceptT ServantErr IO Response

  importEvent etype blob =
    \note{withSomeSing etype \$ \ (_ :: Sing \type{et}) ->}
      case fromJSON blob of
        Error err ->
          throwM err

        Success (e :: Payload et) ->
          pure . Response \$ MkEvent e
\end{raw}

----

No instance `FromJSON` for type `et`.

----

\begin{hs}
  dictFromJSON :: ( FromJSON (Payload 'WakeUp)
                  , FromJSON (Payload 'Eat)
                  , FromJSON (Payload 'RockOut)
                  )
               => Sing (a :: EventType)
               -> Dict (FromJSON (Payload a))
\end{hs}

----

add constraint kind

----

\begin{hs}
  dictFromJSON :: ( FromJSON (Payload 'WakeUp)
                  , FromJSON (Payload 'Eat)
                  , FromJSON (Payload 'RockOut)
                  )
               => Sing (a :: EventType)
               -> Dict (FromJSON (Payload a))

  dictFromJSON = \case
    SWakeUp  -> Dict
    SEat     -> Dict
    SRockOut -> Dict
\end{hs}

----

add lambda case

----

\begin{raw}
  importEvent :: EventType
              -> Value
              -> ExceptT ServantErr IO Response

  importEvent etype blob =
    withSomeSing etype \$ \ (\note{setype} :: Sing \type{et}) ->
      \note{case dictFromJSON setype of}
        \note{Dict ->}
          case fromJSON blob of
            Error err ->
              throwM err

            Success (e :: Payload \type{et}) ->
              pure . Response \$ MkEvent e
\end{raw}

----

\begin{raw}
  eventServer :: Server EventAPI
  eventServer = serve \note{importEvent}
\end{raw}

----

- sweet! our API implementation is done! we now get all of this for free!
  - we can add new event types to our enum
  - but we'll get a exhaustiveness error on dictFromJSON
  - which it can only be fixed if we add a data instance for the new type
  - and then everything works.
  - COMPILER DRIVEN CODING!

----

- but what about the other part of the problem?
  - we also want to serialize these things and stick them into a pipe for downstream consumers
  - for simplicity we'll encode them as json
  - assume we have some `Value -> IO ()` pipe function that sends things downstream. how can we call this function?
    - we need a ToJSON Event, duh
    - well if we want any chance of encoding it, we're going to need to know that ToJSON is total over the sum space
    - also need dictToJSON

----

\begin{hs}
  dictToJSON :: ( ToJSON (Payload 'WakeUp)
                , ToJSON (Payload 'Eat)
                , ToJSON (Payload 'RockOut)
                )
             => Sing (a :: EventType)
             -> Dict (ToJSON (Payload a))

  dictToJSON = \case
    SWakeUp  -> Dict
    SEat     -> Dict
    SRockOut -> Dict
\end{hs}

----

- but you'll notice that besides the constraints, this function is exactly the same implementation as dictFromJSON
  - maybe we can lift this!
    - dictEvent :: (c ...) => Sing (a :: EventType) -> Dict (c (Payload a))
  - this means that we can get a dictionary for any c (Payload a) so long as c is total over Payload a!
    - fucking sweet!

----

\begin{raw}
  dictPayload :: ( \note{c} (Payload '\type{WakeUp})
                 , \note{c} (Payload '\type{Eat})
                 , \note{c} (Payload '\type{RockOut})
                 )
              => Sing (\type{a} :: \kind{EventType})
              -> Dict (\note{c} (Payload \type{a}))

  dictPayload = \case
    SWakeUp  -> Dict
    SEat     -> Dict
    SRockOut -> Dict
\end{raw}

----

\begin{hs}
  instance ToJSON Event where
    toJSON (MkEvent payload) = toJSON payload
\end{hs}

----

No instance `toJSON` for `Payload a`

Uh oh, we don't have a singleton to actually use to get our `dictPayload`!

Scrub lords!

----

\begin{raw}
  data Event where
    MkEvent :: \note{Sing (\type{et} :: \kind{EventType})}
            -> Payload \type{et}
            -> Event
\end{raw}

----

\begin{hs}
  instance ToJSON Event where

    toJSON (MkEvent (setype :: Sing etype) payload) =
      case dictPayload @ToJSON setype of
        Dict ->
          object [ "type"    .= fromSing setype
                 , "payload" .= payload
                 ]
\end{hs}

----

$$\\sum_\\text{a :: EventType} \\text{Payload}(a)$$

----

$$\\sum_\\text{a :: EventType} \\text{Payload}(a) = \\text{Payload}(a_1) + \\text{Payload}(a_2) + \\cdots + \\text{Payload}(a_n)$$

----

Look familiar?
==============

\begin{hs}
  data Event = PayloadWakeUp  (Payload WakeUp)
             | PayloadEat     (Payload Eat)
             | PayloadRockOut (Payload RockOut)
\end{hs}

----

More generally.
===============

$$(a, b) :: \\sum_\\text{a :: A} \\text{F}(a)$$

----

\begin{hs}
  data Some1 (f :: k -> *) where
    Some1 :: Sing (a :: k) -> f a -> Some1 f
\end{hs}

----

Add polykinds.

----

\begin{raw}
  type Event = \note{Some1 Payload}
\end{raw}

----

\begin{hs}
  class Dict1 (c :: ok -> Constraint)
              (f :: ik -> ok) where
    dict1 :: Sing (a :: ik) -> Dict (c (f a))
\end{hs}

